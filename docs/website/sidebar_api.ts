import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';
import doxygenSidebarQarStreamingCItems from './sidebar-category-doxygen-qar-streaming-c.json';
import doxygenSidebarQarStreamingItems from './sidebar-category-doxygen-qar-streaming.json';
import fs from 'fs';
import path from 'path';

// This runs in Node.js - Don't use client-side code here (browser APIs, JSX...)

/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

Create as many sidebars as you want.
 */
// Recursively remove entire category nodes whose label matches any value in
// labelsToRemove. Only removes nodes with type === 'category'.
function pruneCategoriesByLabels(node: any, labelsToRemove: string[]): any {
  if (Array.isArray(node)) return node.map((n) => pruneCategoriesByLabels(n, labelsToRemove)).filter(Boolean);
  if (!node || typeof node !== 'object') return node;
  if (node.type === 'category' && typeof node.label === 'string' && labelsToRemove.includes(node.label)) {
    return null; // drop this category entirely
  }
  const copy: any = { ...node };
  if (Array.isArray(copy.items)) {
    copy.items = copy.items.map((n: any) => pruneCategoriesByLabels(n, labelsToRemove)).filter(Boolean);
  }
  return copy;
}

const DOXY_C_API_REMOVE_LABELS = ['Pages'];
const doxygenCapiRootPruned = pruneCategoriesByLabels(
  doxygenSidebarQarStreamingCItems as any,
  DOXY_C_API_REMOVE_LABELS,
);

const sidebars: SidebarsConfig = {
  // By default, Docusaurus generates a sidebar from the docs folder structure
  // tutorialSidebar: [{ type: 'autogenerated', dirName: '.' }],

  // But you can create a sidebar manually
  /*
  tutorialSidebar: [
    'intro',
    'hello',
    {
      type: 'category',
      label: 'Tutorial',
      items: ['tutorial-basics/create-a-document'],
    },
  ],
   */
  // Important: the JSON files above are generated by doxygen2docusaurus.
  // Do not modify them directly â€” they get overwritten on regenerate.
  // Instead, augment them here with any extra top-level categories we want.
  doxygenSidebar: [
    // C API: add a top-level Files category to reveal functions per-file
    {
      ...(doxygenCapiRootPruned as any),
      items: [
        ...((doxygenCapiRootPruned as any).items ?? []),
        {
          type: 'category',
          label: 'Files',
          link: { type: 'doc', id: 'qar-streaming-c/indices/files/index' },
          collapsed: true,
          items: buildFileDocItems('qar-streaming-c/files'),
        },
        {
          type: 'category',
          label: 'Examples',
          collapsed: false,
          items: [{
            id: 'qar-streaming-c/pages/qar-c-tutorial-dynamic-loading',
            type: 'doc',
            label: 'Init Session',
          }
          ],
        },
      ],
    } as any,

    // C++ API: also add a top-level Files category (functions are indexed
    // under Namespaces/Functions already, but Files is useful navigation)
    {
      ...(doxygenSidebarQarStreamingItems as any),
      items: [
        ...((doxygenSidebarQarStreamingItems as any).items ?? []),
        // Quick access to all namespace-level functions
        {
          type: 'category',
          label: 'Files',
          link: { type: 'doc', id: 'qar-streaming/indices/files/index' },
          collapsed: true,
          items: buildFileDocItems('qar-streaming/files'),
        },
      ],
    } as any,
  ],
};

// Build file doc items with human-friendly labels parsed from the page H1.
function buildFileDocItems(dirName: string) {
  try {
    const absDir = path.join(__dirname, 'api', dirName);
    const entries = fs.readdirSync(absDir, { withFileTypes: true });
    const mdFiles = entries
      .filter((e) => e.isFile() && e.name.toLowerCase().endsWith('.md'))
      .map((e) => path.join(absDir, e.name));

    type DocItem = { type: 'doc'; id: string; label: string };
    type TreeNode = { label?: string; children: Map<string, TreeNode>; docs: DocItem[] };
    const root: TreeNode = { children: new Map(), docs: [] };

    const getOrCreate = (node: TreeNode, seg: string): TreeNode => {
      if (!node.children.has(seg)) node.children.set(seg, { label: seg, children: new Map(), docs: [] });
      return node.children.get(seg)!;
    };

    for (const absFile of mdFiles) {
      const relPathFromApi = path.relative(path.join(__dirname, 'api'), absFile);
      const id = relPathFromApi.replace(/\\/g, '/').replace(/\.md$/i, '');

      let label: string | undefined;
      let slugParts: string[] | undefined;
      try {
        const content = fs.readFileSync(absFile, 'utf8');
        // Extract human label from H1
        const mBacktick = content.match(/^#\s+`([^`]+)`/m);
        if (mBacktick?.[1]) {
          label = mBacktick[1];
        } else {
          const mH1 = content.match(/^#\s+(.+)$/m);
          if (mH1?.[1]) label = mH1[1].replace(/\s+File\s*$/, '');
        }
        // Extract hierarchical parts from slug: /<api>/files/<part>/<part>/...
        const mSlug = content.match(/^slug:\s*\/(qar-streaming|qar-streaming-c)\/files\/([^\r\n#]+)/m);
        if (mSlug?.[2]) {
          slugParts = mSlug[2].split('/').filter(Boolean);
        }
      } catch {
        // ignore
      }
      if (!label) label = path.basename(absFile, '.md');

      const doc: DocItem = { type: 'doc', id, label };

      if (slugParts && slugParts.length > 1) {
        // All but last are folders, last is file token
        let node = root;
        for (let i = 0; i < slugParts.length - 1; i++) {
          const seg = slugParts[i];
          node = getOrCreate(node, seg);
        }
        node.docs.push(doc);
      } else {
        // Fallback: flat
        root.docs.push(doc);
      }
    }

    const toItems = (node: TreeNode): any[] => {
      const items: any[] = [];
      // First categories (folders)
      const segs = Array.from(node.children.keys()).sort((a, b) => a.localeCompare(b));
      for (const seg of segs) {
        const child = node.children.get(seg)!;
        items.push({
          type: 'category',
          label: seg,
          collapsed: true,
          items: toItems(child),
        });
      }
      // Then docs in this node
      const docs = [...node.docs].sort((a, b) => a.label.localeCompare(b.label));
      items.push(...docs);
      return items;
    };

    return toItems(root);
  } catch {
    // If anything fails (e.g., during early builds), fall back to autogenerated
    return [{ type: 'autogenerated', dirName: dirName }];
  }
}

export default sidebars;
